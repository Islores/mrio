<!doctype html>
<!--
  Super Mario-style platformer
  Single-file index.html containing HTML, CSS, and JavaScript (Canvas-based)
  Features:
   - Tile-based level format
   - Player with running, jumping, gravity, collisions
   - Enemies (walker + flyer) with simple AI
   - Collectible coins and power-ups
   - Parallax background, camera following player
   - HUD (score, lives, level)
   - Level loader with multiple levels encoded as strings
   - Simple level editor console to add tiles live
   - Keyboard + gamepad support
   - Pause, restart, and debug view (tile grid, FPS)
   - Sound effects (WebAudio synth) and music loop (very simple)

  Notes:
   - This is intentionally verbose and commented for learning and extension.
   - Replace placeholder asset generation with real spritesheets for production.
-->
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Super-Mario-Style Platformer — Single File</title>
  <style>
    /* Reset */
    html,body,div,canvas{margin:0;padding:0;border:0}
    html,body{height:100%;background:#7ec0ee;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}

    /* Layout */
    #game-wrap{display:flex;flex-direction:column;align-items:center;gap:10px;padding:12px}
    #topbar{width:100%;max-width:1200px;display:flex;justify-content:space-between;align-items:center}
    #title{font-weight:700;color:#052a4a}
    #controls{display:flex;gap:8px;align-items:center}
    button{background:#0b5bd7;color:white;border-radius:8px;padding:8px 12px;border:none;cursor:pointer}
    button.secondary{background:#eee;color:#333}
    button.small{padding:6px 10px;font-size:13px}

    /* Canvas */
    #viewport{background:linear-gradient(#80d0ff,#b3ecff);box-shadow:0 8px 30px rgba(2,18,43,0.12);border-radius:8px}

    /* HUD */
    #hud{position:relative;display:flex;gap:12px;align-items:center}
    .hud-item{background:rgba(255,255,255,0.9);padding:6px 10px;border-radius:8px;box-shadow:0 3px 10px rgba(2,18,43,0.06)}

    /* Info / Debug */
    #debug{max-width:1200px;width:100%;background:rgba(255,255,255,0.95);padding:10px;border-radius:8px;display:flex;gap:10px;flex-direction:column}
    pre{white-space:pre-wrap;font-family:Menlo,monospace}

    /* Tiny responsive */
    @media (max-width:720px){#viewport{width:100%}}
  </style>
</head>
<body>
  <div id="game-wrap">
    <div id="topbar">
      <div id="title">Super-ish Platformer — Single File</div>
      <div id="controls">
        <div id="hud" aria-hidden>
          <div class="hud-item">Score: <span id="score">0</span></div>
          <div class="hud-item">Coins: <span id="coins">0</span></div>
          <div class="hud-item">Lives: <span id="lives">3</span></div>
          <div class="hud-item">Level: <span id="levelNum">1</span></div>
        </div>
        <button id="btn-start">Start</button>
        <button id="btn-pause" class="secondary small">Pause</button>
        <button id="btn-restart" class="secondary small">Restart</button>
        <button id="btn-editor" class="secondary small">Editor</button>
      </div>
    </div>

    <canvas id="viewport" width="1024" height="576"></canvas>

    <div id="debug" hidden>
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>Debug Console</strong>
        <div>
          <button id="toggle-fps" class="small secondary">Toggle FPS</button>
        </div>
      </div>
      <pre id="debugText">Ready.</pre>
    </div>

    <div style="max-width:1200px;width:100%;display:flex;justify-content:space-between">
      <div style="flex:1;margin-right:12px">
        <h3 style="margin:8px 0">Level Controls</h3>
        <textarea id="levelInput" style="width:100%;height:160px;font-family:monospace" spellcheck="false"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="loadLevel">Load Level</button>
          <button id="saveLevel" class="secondary">Export Level</button>
          <button id="sampleLevel" class="secondary">Sample Level</button>
        </div>
      </div>
      <div style="width:320px">
        <h3 style="margin:8px 0">Help & Shortcuts</h3>
        <ul>
          <li>Arrows / A D = move</li>
          <li>W / Up / Space = jump</li>
          <li>P = pause</li>
          <li>F = toggle debug grid</li>
          <li>Enter = respawn when dead</li>
        </ul>
        <h3 style="margin:8px 0">Author Notes</h3>
        <p style="font-size:13px;margin:0">This single file demo uses canvas drawing and procedural sprites so you can run & edit without external images. It's fairly extensible — paste tilemaps in the level box and press Load Level.</p>
      </div>
    </div>
  </div>

  <script>
  // =================================================================================
  // SUPER-MARIO-STYLE PLATFORMER — Single-file Implementation
  // =================================================================================
  // Anatomy:
  //  - Constants & globals
  //  - Input system (keyboard + gamepad)
  //  - Level encoding & loader
  //  - Tile collision, world, camera
  //  - Entities: player, enemy, coin, power-up
  //  - Renderer: parallax backgrounds, tilemap draw, entities
  //  - Physics & collision resolution
  //  - Game loop & state
  //  - UI hooks (start, pause, editor)
  //  - Simple music & SFX via WebAudio
  // =================================================================================

  // ---------- Constants ----------
  const TILE = 32;                 // tile size in pixels
  const GRAVITY = 1600;           // pixels / s^2
  const MAX_FALL_SPEED = 1400;    // terminal velocity
  const RUN_ACCEL = 2200;
  const RUN_FRICTION = 0.85;
  const JUMP_IMPULSE = 520;       // initial jump velocity
  const CANVAS_W = 1024;
  const CANVAS_H = 576;
  const DEBUG = {grid:false, fps:false};

  // ---------- Globals & Engine State ----------
  const canvas = document.getElementById('viewport');
  const ctx = canvas.getContext('2d');
  let lastTime = 0;
  let accum = 0;
  const MS_PER_UPDATE = 1000/60;

  // Game state
  const Game = {
    running: false,
    paused: false,
    levelIndex: 0,
    levels: [],
    world: null,
    player: null,
    entities: [],
    score: 0,
    coins: 0,
    lives: 3,
    fps: 0
  };

  // Input
  const Input = {left:false,right:false,up:false,jump:false,pause:false,editor:false};

  // WebAudio context for SFX
  let audioCtx = null;

  // Simple color palette for procedural sprites
  const palette = {
    skyTop: '#80d0ff', skyBot: '#b3ecff',
    ground: '#6a4f2b',
    platform: '#8a6a43',
    player: '#d9534f',
    enemy: '#3a3a3a',
    coin: '#ffd24a',
  };

  // ---------- Utility helpers ----------
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}

  function now(){return performance.now()}

  function lerp(a,b,t){return a+(b-a)*t}

  // Simple rectangle collision test
  function rectsOverlap(a,b){
    return !(a.x+b.width <= b.x || a.x >= b.x+b.width || a.y+b.height <= b.y || a.y >= b.y+b.height);
  }

  // ---------- Input handling ----------
  window.addEventListener('keydown',e=>{
    if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') Input.left = true;
    if(e.key==='ArrowRight' || e.key==='d' || e.key==='D') Input.right = true;
    if(e.key==='ArrowUp' || e.key==='w' || e.key==='W' || e.code==='Space') Input.up = true;
    if(e.key===' '|| e.code==='Space') Input.jump = true;
    if(e.key==='p' || e.key==='P') togglePause();
    if(e.key==='f' || e.key==='F') { DEBUG.grid=!DEBUG.grid; document.getElementById('debug').hidden = !DEBUG.grid; }
    if(e.key==='Enter'){ if(!Game.running) startGame(); else if(Game.player && Game.player.dead) respawnPlayer(); }
  });
  window.addEventListener('keyup',e=>{
    if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A') Input.left = false;
    if(e.key==='ArrowRight' || e.key==='d' || e.key==='D') Input.right = false;
    if(e.key==='ArrowUp' || e.key==='w' || e.key==='W' || e.code==='Space') Input.up = false;
    if(e.key===' '|| e.code==='Space') Input.jump = false;
  });

  // Basic gamepad poll
  function pollGamepad(){
    const gps = navigator.getGamepads ? navigator.getGamepads() : [];
    if(!gps) return;
    for(let gp of gps){ if(!gp) continue;
      // Button mapping is not standard across devices. We'll support left stick & dpad.
      Input.left = gp.axes[0] < -0.4 || gp.buttons[14] && gp.buttons[14].pressed;
      Input.right = gp.axes[0] > 0.4 || gp.buttons[15] && gp.buttons[15].pressed;
      Input.jump = gp.buttons[0] && gp.buttons[0].pressed; // A
    }
  }

  // ---------- Level Encoding & Tilemap ----------
  // We'll define a compact text-based level format: rows of characters, each char is a tile.
  // Legend (single char):
  //  '.' => empty
  //  '#' => solid ground block
  //  '-' => platform (one-way)
  //  'P' => player spawn
  //  'E' => basic enemy
  //  'C' => coin
  //  'G' => goomba-like (enemy)
  //  'S' => spike (hazard)
  //  'L' => level end (flag)
  //  'B' => breakable block (placeholder)

  function Level(w,h,lines){
    this.width = w; this.height = h; this.tiles = new Array(h);
    for(let y=0;y<h;y++){
      this.tiles[y] = new Array(w).fill('.');
      if(lines && lines[y]){
        for(let x=0;x<Math.min(w,lines[y].length);x++) this.tiles[y][x] = lines[y].charAt(x);
      }
    }
  }

  Level.prototype.get = function(x,y){
    if(x<0||y<0||x>=this.width||y>=this.height) return '#'; // treat oob as solid
    return this.tiles[y][x];
  }

  Level.prototype.set = function(x,y,ch){ if(x<0||y<0||x>=this.width||y>=this.height) return; this.tiles[y][x]=ch; }

  // Sample levels
  const sampleLevels = [
    // Level 1: simple ground, coins, one enemy and platform
    `..............................................................
..............................................................
..............................................................
..............................................................
....................................................C.........
......................C.......................................
........P..............-----...............C...................
###############################......##########################
` ,
    // Level 2: pits + stairs
    `................................................................................................
................................................................................................
.......C........................................................................................
..................................................E.............................................
....................-----.......................................................................
......P.........................................................................................
#####################.....###############.......##########...#############################.....
` ,
  ];

  // ---------- World builder & loader ----------
  function buildWorldFromText(text){
    const lines = text.split('\n').map(l=>l.replace(/\r/g,''));
    const h = lines.length;
    const w = Math.max(...lines.map(l=>l.length));
    const level = new Level(w,h,lines);
    Game.world = { level, width: w*TILE, height: h*TILE };
    spawnEntitiesFromLevel(level);
  }

  function spawnEntitiesFromLevel(level){
    Game.entities = [];
    Game.player = null;
    for(let y=0;y<level.height;y++){
      for(let x=0;x<level.width;x++){
        const ch = level.get(x,y);
        const px = x*TILE, py = y*TILE;
        if(ch==='P'){
          Game.player = new Player(px,py - (TILE-20));
          level.set(x,y,'.');
        }
        if(ch==='E' || ch==='G'){
          Game.entities.push(new Enemy(px,py-12,'walker'));
          level.set(x,y,'.');
        }
        if(ch==='C'){
          Game.entities.push(new Coin(px+TILE/4,py+TILE/4));
          level.set(x,y,'.');
        }
        if(ch==='S'){
          Game.entities.push(new Spike(px,py));
          level.set(x,y,'.');
        }
        if(ch==='L'){
          Game.entities.push(new Flag(px,py));
          level.set(x,y,'.');
        }
      }
    }
    if(!Game.player){
      // fallback spawn
      Game.player = new Player(64, (level.height-3)*TILE);
    }
    // camera
    Game.camera = {x:0,y:0,w:CANVAS_W,h:CANVAS_H};
  }

  // ---------- Entities ----------
  function Entity(x,y,w,h){ this.x = x; this.y = y; this.width = w; this.height = h; this.vx=0; this.vy=0; this.dead=false; }

  function Player(x,y){
    Entity.call(this,x,y,22,28);
    this.speed = 0; this.onGround=false; this.canDoubleJump=false; this.facing = 1; this.invuln = 0; this.dead=false;
  }
  Player.prototype = Object.create(Entity.prototype);

  Player.prototype.update = function(dt){
    // Horizontal control
    let ax = 0;
    if(Input.left) ax -= RUN_ACCEL;
    if(Input.right) ax += RUN_ACCEL;
    // apply acceleration
    this.vx += ax*dt;
    // apply friction
    if(!Input.left && !Input.right) this.vx *= Math.pow(RUN_FRICTION, dt*60);
    // clamp
    this.vx = clamp(this.vx, -400, 400);

    // Jumping
    if((Input.up || Input.jump) && (this.onGround || this.canDoubleJump)){
      if(this.onGround){ this.vy = -JUMP_IMPULSE; this.onGround=false; this.canDoubleJump=true; playSfx('jump'); }
      else if(this.canDoubleJump){ this.vy = -JUMP_IMPULSE*0.9; this.canDoubleJump=false; playSfx('jump'); }
    }

    // Gravity
    this.vy += GRAVITY*dt;
    this.vy = clamp(this.vy, -1000, MAX_FALL_SPEED);

    // Movement + collision
    this.x += this.vx*dt;
    collideWithWorld(this, true);
    this.y += this.vy*dt;
    collideWithWorld(this, false);

    // camera follow
    centerCameraOn(this);

    // death by falling
    if(this.y > Game.world.height + 500){
      this.die();
    }
  }

  Player.prototype.die = function(){
    if(this.dead) return;
    this.dead = true;
    Game.lives -= 1; updateHUD(); playSfx('die');
    if(Game.lives<0){
      Game.running=false; document.getElementById('debugText').textContent = 'Game Over. Press Start to play again.';
    }
  }

  // Enemy (simple walker)
  function Enemy(x,y,type){ Entity.call(this,x,y,24,24); this.type = type || 'walker'; this.dir = -1; this.speed = 40 + Math.random()*40; }
  Enemy.prototype = Object.create(Entity.prototype);
  Enemy.prototype.update = function(dt){
    if(this.dead) return;
    // simple patrol logic: walk until blocked then reverse
    this.vx = this.dir*this.speed;
    this.x += this.vx*dt;
    const blocked = collideWithWorld(this, true);
    if(blocked) { this.dir *= -1; this.x += this.dir*this.speed*dt; }
    // apply gravity
    this.vy += GRAVITY*dt;
    this.vy = clamp(this.vy, -1000, MAX_FALL_SPEED);
    this.y += this.vy*dt;
    collideWithWorld(this, false);
  }

  // Coin
  function Coin(x,y){ Entity.call(this,x,y,18,18); this.collected=false; }
  Coin.prototype = Object.create(Entity.prototype);

  // Spike (hazard)
  function Spike(x,y){ Entity.call(this,x,y,32,16); }
  Spike.prototype = Object.create(Entity.prototype);

  // Flag
  function Flag(x,y){ Entity.call(this,x,y,24,48); this.raised=false; }
  Flag.prototype = Object.create(Entity.prototype);

  // ---------- Collision with tilemap ----------
  function collideWithWorld(ent, horizOnly){
    const level = Game.world.level;
    // We'll check tile corners
    const startX = Math.floor(ent.x / TILE) - 1;
    const endX = Math.floor((ent.x + ent.width) / TILE) + 1;
    const startY = Math.floor(ent.y / TILE) - 1;
    const endY = Math.floor((ent.y + ent.height) / TILE) + 1;
    let collided = false;
    for(let ty=startY; ty<=endY; ty++){
      for(let tx=startX; tx<=endX; tx++){
        const ch = level.get(tx,ty);
        if(ch==='#' || ch==='B'){
          const tileRect = {x:tx*TILE,y:ty*TILE,width:TILE,height:TILE};
          // axis-aligned collision resolution
          if(intersectRect(ent, tileRect)){
            collided = true;
            // push out horizontally or vertically depending on movement
            const dx = (ent.x + ent.width/2) - (tileRect.x + tileRect.width/2);
            const dy = (ent.y + ent.height/2) - (tileRect.y + tileRect.height/2);
            const wy = (ent.width/2 + tileRect.width/2) * Math.abs(dy);
            const hx = (ent.height/2 + tileRect.height/2) * Math.abs(dx);
            if(hx > wy && !horizOnly){
              // vertical collision
              if(dy < 0){ // entity is above tile
                ent.y = tileRect.y - ent.height - 0.01; ent.vy = 0; ent.onGround=true; ent.canDoubleJump=false;
              } else { // entity below tile
                ent.y = tileRect.y + tileRect.height + 0.01; ent.vy = 0; }
            }else{
              // horizontal collision
              if(dx < 0){ ent.x = tileRect.x - ent.width - 0.01; ent.vx = 0; }
              else { ent.x = tileRect.x + tileRect.width + 0.01; ent.vx = 0; }
            }
          }
        }
        // one-way platforms (-): only collide from above
        if(ch==='-'){
          const tileRect = {x:tx*TILE,y:ty*TILE,width:TILE,height:6};
          // only collide if entity was above and moving downward
          if(ent.vy >= 0 && ent.y + ent.height <= tileRect.y + 12 && intersectRect(ent,tileRect)){
            ent.y = tileRect.y - ent.height - 0.01; ent.vy = 0; ent.onGround=true; ent.canDoubleJump=false; collided = true;
          }
        }
      }
    }
    return collided;
  }

  function intersectRect(a,b){
    return !(a.x + a.width <= b.x || a.x >= b.x + b.width || a.y + a.height <= b.y || a.y >= b.y + b.height);
  }

  // ---------- Camera ----------
  function centerCameraOn(entity){
    const cam = Game.camera;
    cam.x = entity.x + entity.width/2 - cam.w/2;
    cam.y = entity.y + entity.height/2 - cam.h/2;
    cam.x = clamp(cam.x, 0, Game.world.width - cam.w);
    cam.y = clamp(cam.y, 0, Game.world.height - cam.h);
  }

  // ---------- Rendering ----------
  function render(){
    // clear with sky gradient
    const grad = ctx.createLinearGradient(0,0,0,canvas.height);
    grad.addColorStop(0,palette.skyTop); grad.addColorStop(1,palette.skyBot);
    ctx.fillStyle = grad; ctx.fillRect(0,0,canvas.width,canvas.height);

    // parallax background layers (clouds / distant hills)
    renderParallax();

    // draw tiles
    drawTiles();

    // draw entities
    for(let ent of Game.entities) drawEntity(ent);

    // draw player
    if(Game.player) drawPlayer(Game.player);

    // HUD overlay: score etc handled in DOM

    // debug grid
    if(DEBUG.grid) drawGrid();
  }

  function renderParallax(){
    const cam = Game.camera;
    // far mountains
    ctx.save();
    ctx.translate(-cam.x*0.2, -cam.y*0.1);
    drawMountains();
    ctx.restore();
    // mid clouds
    ctx.save(); ctx.translate(-cam.x*0.4, -cam.y*0.05); drawClouds(); ctx.restore();
  }

  function drawMountains(){
    const w = Game.world.width; const h = Game.world.height;
    ctx.fillStyle = '#3c6b5a';
    for(let i=-2;i<6;i++){
      const x = i*400; const y = Game.camera.h*0.8; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+200,y-140); ctx.lineTo(x+400,y); ctx.closePath(); ctx.fill();
    }
  }

  function drawClouds(){
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    for(let i=0;i<8;i++){ const x = (i*300 + (Game.camera.x*0.05)%300) % (Game.world.width); const y=60 + (i%3)*30; ctx.beginPath(); ctx.ellipse(x,y,60,28,0,0,Math.PI*2); ctx.fill(); }
  }

  function drawTiles(){
    const level = Game.world.level;
    const cam = Game.camera;
    const startX = Math.floor(cam.x / TILE);
    const endX = Math.floor((cam.x + cam.w) / TILE)+1;
    const startY = Math.floor(cam.y / TILE);
    const endY = Math.floor((cam.y + cam.h) / TILE)+1;
    for(let y=startY;y<=endY;y++){
      for(let x=startX;x<=endX;x++){
        const ch = level.get(x,y);
        const sx = x*TILE - cam.x; const sy = y*TILE - cam.y;
        if(ch==='#' || ch==='B'){
          // draw block
          ctx.fillStyle = '#8a6a43'; ctx.fillRect(sx,sy,TILE,TILE);
          // simple face to make blocks readable
          ctx.fillStyle = 'rgba(0,0,0,0.06)'; ctx.fillRect(sx+4,sy+4,TILE-8,TILE-8);
        } else if(ch==='-'){
          ctx.fillStyle = '#b07b4f'; ctx.fillRect(sx,sy+TILE-8,TILE,8);
        }
      }
    }
  }

  function drawEntity(ent){
    if(ent instanceof Coin){
      if(ent.collected) return;
      drawCoin(ent.x - Game.camera.x, ent.y - Game.camera.y);
      return;
    }
    if(ent instanceof Spike){
      drawSpike(ent.x - Game.camera.x, ent.y - Game.camera.y); return;
    }
    if(ent instanceof Flag){
      drawFlag(ent.x - Game.camera.x, ent.y - Game.camera.y, ent.raised);
      return;
    }
    // generic enemy
    ctx.save(); ctx.translate(ent.x - Game.camera.x, ent.y - Game.camera.y);
    ctx.fillStyle = palette.enemy; ctx.fillRect(0,0,ent.width,ent.height);
    ctx.restore();
  }

  function drawPlayer(p){
    const sx = p.x - Game.camera.x; const sy = p.y - Game.camera.y;
    ctx.save(); ctx.translate(sx,sy);
    // body
    ctx.fillStyle = palette.player; ctx.fillRect(0,0,p.width,p.height);
    // eyes
    ctx.fillStyle = 'white'; ctx.fillRect(p.width-12,6,6,6);
    ctx.fillStyle = 'black'; ctx.fillRect(p.width-10,8,3,3);
    ctx.restore();
  }

  function drawCoin(x,y){ ctx.save(); ctx.translate(x,y); ctx.beginPath(); ctx.ellipse(9,9,8,8,0,0,Math.PI*2); ctx.fillStyle=palette.coin; ctx.fill(); ctx.restore(); }
  function drawSpike(x,y){ ctx.save(); ctx.translate(x,y); ctx.beginPath(); ctx.moveTo(0,16); ctx.lineTo(8,0); ctx.lineTo(16,16); ctx.closePath(); ctx.fillStyle='#c0392b'; ctx.fill(); ctx.restore(); }
  function drawFlag(x,y,raised){ ctx.save(); ctx.translate(x,y); ctx.fillStyle='#2e86de'; ctx.fillRect(2,8,6,40); ctx.fillStyle='#f39c12'; ctx.fillRect(8,8,18,12); ctx.restore(); }

  function drawGrid(){
    const cam = Game.camera; ctx.save(); ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(0,0,0,0.06)';
    for(let x = - (cam.x%TILE); x < canvas.width; x+=TILE){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
    for(let y = - (cam.y%TILE); y < canvas.height; y+=TILE){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }
    ctx.restore();
  }

  // ---------- Game loop & state ----------
  function step(dt){
    if(!Game.running || Game.paused) return;
    pollGamepad();
    // update player & entities
    if(Game.player && !Game.player.dead) Game.player.update(dt);
    for(let ent of Game.entities){
      if(ent instanceof Enemy) ent.update(dt);
      // check interactions
      if(ent instanceof Coin && !ent.collected && intersectRect(Game.player, ent)){
        ent.collected = true; Game.coins++; Game.score += 100; updateHUD(); playSfx('coin');
      }
      if(ent instanceof Enemy && !ent.dead){
        if(intersectRect(Game.player, ent)){
          // if player is falling onto enemy, kill enemy
          if(Game.player.vy > 150){ ent.dead=true; Game.player.vy = -220; Game.score += 200; playSfx('stomp'); }
          else { Game.player.die(); }
        }
      }
      if(ent instanceof Spike && intersectRect(Game.player, ent)){
        Game.player.die();
      }
      if(ent instanceof Flag && intersectRect(Game.player, ent)){
        // level complete!
        Game.running = false; playSfx('level'); document.getElementById('debugText').textContent = 'Level complete! Press Start for next.';
      }
    }
    // simple entity cleanup
    Game.entities = Game.entities.filter(e=>!((e instanceof Enemy) && e.dead));
  }

  function loop(ts){
    if(!lastTime) lastTime = ts; const delta = ts - lastTime; lastTime = ts;
    accum += delta;
    let updated = false;
    while(accum >= MS_PER_UPDATE){ step(MS_PER_UPDATE/1000); accum -= MS_PER_UPDATE; updated = true; }
    if(updated) render();
    // fps calc
    Game.fps = Math.round(1000 / (delta || 1));
    if(DEBUG.fps) document.getElementById('debugText').textContent = `FPS: ${Game.fps}`;
    requestAnimationFrame(loop);
  }

  // ---------- HUD & UI ----------
  function updateHUD(){
    document.getElementById('score').textContent = Game.score;
    document.getElementById('coins').textContent = Game.coins;
    document.getElementById('lives').textContent = Game.lives;
    document.getElementById('levelNum').textContent = Game.levelIndex+1;
  }

  document.getElementById('btn-start').addEventListener('click',()=>{
    if(!Game.running) startGame(); else { Game.paused = false; document.getElementById('btn-pause').textContent = 'Pause'; }
  });
  document.getElementById('btn-pause').addEventListener('click',()=>{ togglePause(); });
  document.getElementById('btn-restart').addEventListener('click',()=>{ restartLevel(); });
  document.getElementById('btn-editor').addEventListener('click',()=>{ document.getElementById('debug').hidden = !document.getElementById('debug').hidden; });

  document.getElementById('loadLevel').addEventListener('click',()=>{
    const txt = document.getElementById('levelInput').value.trim(); if(!txt) return; buildWorldFromText(txt); Game.running=true; updateHUD(); document.getElementById('debugText').textContent='Level loaded.';
  });
  document.getElementById('sampleLevel').addEventListener('click',()=>{ document.getElementById('levelInput').value = sampleLevels[0]; });
  document.getElementById('saveLevel').addEventListener('click',()=>{ const txt = document.getElementById('levelInput').value; prompt('Copy your level (CTRL+C)', txt); });

  // ---------- Level management ----------
  function startGame(){
    Game.running = true; Game.paused=false; if(!Game.world) buildWorldFromText(sampleLevels[0]); updateHUD(); document.getElementById('debugText').textContent='Game started.'; lastTime=0; requestAnimationFrame(loop); initAudio();
  }
  function restartLevel(){ if(Game.world) spawnEntitiesFromLevel(Game.world.level); Game.player.dead=false; Game.player.x=64; Game.player.y=64; Game.score=0; Game.coins=0; updateHUD(); }
  function respawnPlayer(){ if(Game.lives<0){ Game.lives=3; Game.score=0; Game.coins=0; } spawnEntitiesFromLevel(Game.world.level); Game.player.dead=false; updateHUD(); }
  function togglePause(){ Game.paused = !Game.paused; document.getElementById('btn-pause').textContent = Game.paused? 'Resume':'Pause'; }

  // ---------- Audio (procedural) ----------
  function initAudio(){ if(audioCtx) return; try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){ console.warn('Audio not supported'); }
  }
  function playSfx(type){ if(!audioCtx) return; const t = audioCtx.currentTime; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination);
    if(type==='coin'){ o.type='sine'; o.frequency.setValueAtTime(880,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.2,t+0.01); o.frequency.exponentialRampToValueAtTime(1760,t+0.12); g.gain.exponentialRampToValueAtTime(0.0001,t+0.45); }
    if(type==='jump'){ o.type='square'; o.frequency.setValueAtTime(440,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.2,t+0.01); o.frequency.exponentialRampToValueAtTime(220,t+0.12); g.gain.exponentialRampToValueAtTime(0.0001,t+0.4); }
    if(type==='stomp'){ o.type='sawtooth'; o.frequency.setValueAtTime(120,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.6,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.25); }
    if(type==='die'){ o.type='sine'; o.frequency.setValueAtTime(110,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.6,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.8); }
    if(type==='level'){ o.type='triangle'; o.frequency.setValueAtTime(660,t); g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.5,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+1); }
    o.start(t); o.stop(t+1.2);
  }

  // ---------- Initialize default content ----------
  document.getElementById('levelInput').value = sampleLevels[0];
  buildWorldFromText(sampleLevels[0]);
  updateHUD();

  // Start loop (will not run game until Start pressed)
  requestAnimationFrame(loop);

  // Expose helpers for console tinkering
  window.__GAME = Game; window.__build = buildWorldFromText; window.__play = playSfx;

  // =================================================================================
  // End of single-file platformer
  // =================================================================================
  </script>
</body>
</html>
